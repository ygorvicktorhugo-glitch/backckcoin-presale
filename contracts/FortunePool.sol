// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "./BKCToken.sol";

// --- Interfaces ---

interface IFortuneEngine {
    /**
     * @notice Calls the Rust/WASM logic to determine game outcome.
     * @param seed Randomness seed derived from block.prevrandao.
     * @param guesses User's predicted numbers.
     * @param mode Game mode (0, 1, or 2).
     * @param difficultyParams Array of current game settings [t1, t2, t3, jackpotNum].
     * @return multiplier Total win multiplier in BIPS (e.g., 150 = 1.5x).
     * @return isJackpot True if the specific jackpot number was hit in Tier 3.
     * @return rolls The actual numbers generated by the oracle (for UI/FOMO).
     */
    function calculate_game_result(
        uint256 seed, 
        uint8[] memory guesses, 
        uint8 mode,
        uint64[] memory difficultyParams 
    ) external view returns (uint256 multiplier, bool isJackpot, uint8[] memory rolls);
}

interface IMiningManager {
    function performPurchaseMining(bytes32 _serviceKey, uint256 _purchaseAmount) external;
}

/**
 * @title Fortune Pool (Hybrid Stylus Edition)
 * @notice A strategic prediction game using Arbitrum Stylus for high-performance computing.
 * @dev Implements "Inverted Risk Ladder": High risk is free, safety/combos cost ETH fees.
 */
contract FortunePool is 
    Initializable, 
    UUPSUpgradeable, 
    OwnableUpgradeable, 
    ReentrancyGuardUpgradeable 
{
    using SafeERC20Upgradeable for BKCToken;

    // --- State Variables ---

    BKCToken public bkcToken;
    IFortuneEngine public stylusEngine;
    address public miningManager;
    address public treasury;

    // Game Configuration (Adjustable via Admin)
    uint64 public tier1Odds;     // e.g., 4 (1/4 chance)
    uint64 public tier2Odds;     // e.g., 12 (1/12 chance)
    uint64 public tier3Odds;     // e.g., 120 (1/120 chance)
    uint64 public jackpotTarget; // e.g., 77 (The winning number for Jackpot)

    // Native ETH Fees for Game Modes
    uint256 public feeMode1; // Cost to unlock Medium Pool protection
    uint256 public feeMode2; // Cost to unlock Easy Pool + Combo possibility

    // Jackpot Economy
    uint256 public jackpotBalance;          // Total BKC in the Jackpot pot
    uint256 public jackpotContributionBips; // % of every wager added to Jackpot (e.g., 200 = 2%)

    bytes32 public constant SERVICE_KEY = keccak256("TIGER_GAME_SERVICE");

    // --- Events ---

    event GamePlayed(
        address indexed user, 
        uint8 mode,           // 0=Daredevil, 1=Protector, 2=Whale
        uint256 wager, 
        uint256 payout, 
        uint256 ethPaid,
        uint8[] rolls,        // The generated numbers (Crucial for FOMO UI)
        uint8[] guesses,
        bool isJackpotHit
    );
    
    event JackpotHit(address indexed winner, uint256 amount);
    event DifficultyUpdated(uint64 t1, uint64 t2, uint64 t3, uint64 target);
    event FeesUpdated(uint256 mode1Fee, uint256 mode2Fee);

    // --- Custom Errors ---

    error InvalidAddress();
    error InvalidAmount();
    error InvalidMode();
    error InsufficientEthFee();
    error InvalidInputs();
    error TransferFailed();

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() { _disableInitializers(); }

    function initialize(
        address _bkcToken, 
        address _stylusEngine, 
        address _miningManager,
        address _treasury
    ) public initializer {
        if (_bkcToken == address(0) || _stylusEngine == address(0)) revert InvalidAddress();

        __Ownable_init();
        __UUPSUpgradeable_init();
        __ReentrancyGuard_init();

        bkcToken = BKCToken(_bkcToken);
        stylusEngine = IFortuneEngine(_stylusEngine);
        miningManager = _miningManager;
        treasury = _treasury;

        // Default Economy Setup
        feeMode1 = 0.0005 ether; // Small fee for Mode 1
        feeMode2 = 0.001 ether;  // Medium fee for Mode 2
        jackpotContributionBips = 200; // 2% contribution

        // Default Difficulty
        tier1Odds = 4;
        tier2Odds = 12;
        tier3Odds = 120;
        jackpotTarget = 77;
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}

    // --- Admin Configuration ---

    function setNativeFees(uint256 _t1, uint256 _t2) external onlyOwner {
        feeMode1 = _t1;
        feeMode2 = _t2;
        emit FeesUpdated(_t1, _t2);
    }

    function setDifficulty(uint64 _t1, uint64 _t2, uint64 _t3, uint64 _target) external onlyOwner {
        require(_t1 > 1 && _t2 > 1 && _t3 > 1, "Odds too low");
        tier1Odds = _t1;
        tier2Odds = _t2;
        tier3Odds = _t3;
        jackpotTarget = _target;
        emit DifficultyUpdated(_t1, _t2, _t3, _target);
    }

    function setStylusEngine(address _addr) external onlyOwner {
        if (_addr == address(0)) revert InvalidAddress();
        stylusEngine = IFortuneEngine(_addr);
    }

    // --- Core Gameplay (Atomic & Hybrid) ---

    /**
     * @notice Play the game.
     * @param _wagerTotal Amount of BKC to wager.
     * @param _guesses User predictions [g1, g2, g3].
     * @param _mode Game Mode: 0 (Hard Only), 1 (Hard+Med), 2 (All + Combo).
     */
    function play(
        uint256 _wagerTotal, 
        uint8[] calldata _guesses, 
        uint8 _mode 
    ) external payable nonReentrant {
        if (_wagerTotal == 0) revert InvalidAmount();
        if (_guesses.length != 3) revert InvalidInputs();
        if (_mode > 2) revert InvalidMode();

        // 1. Validate & Route Native ETH Fee
        uint256 requiredEth = 0;
        if (_mode == 1) requiredEth = feeMode1;
        else if (_mode == 2) requiredEth = feeMode2;

        if (msg.value < requiredEth) revert InsufficientEthFee();

        // Send ETH to Treasury (Protocol Revenue)
        if (msg.value > 0) {
            (bool sent, ) = treasury.call{value: msg.value}("");
            if (!sent) revert TransferFailed();
        }

        // 2. Pull BKC Wager
        bkcToken.safeTransferFrom(msg.sender, address(this), _wagerTotal);

        // 3. Prepare Stylus Parameters
        // Generate secure entropy from Arbitrum Sequencer
        uint256 seed = uint256(keccak256(abi.encodePacked(
            block.prevrandao, 
            block.timestamp, 
            msg.sender, 
            block.number
        )));

        // Pack current difficulty settings to send to Rust
        uint64[] memory params = new uint64[](4);
        params[0] = tier1Odds;
        params[1] = tier2Odds;
        params[2] = tier3Odds;
        params[3] = jackpotTarget;

        // 4. Call The Brain (Rust/Stylus)
        (uint256 multiplier, bool isJackpot, uint8[] memory rolls) = 
            stylusEngine.calculate_game_result(seed, _guesses, _mode, params);

        // 5. Calculate Payouts
        uint256 payout = 0;
        
        // Split Wager: Jackpot Contribution vs Operational
        uint256 jackpotCut = (_wagerTotal * jackpotContributionBips) / 10000;
        jackpotBalance += jackpotCut;
        uint256 operationalWager = _wagerTotal - jackpotCut;

        // Base Payout (Multiplier is in BIPS, e.g., 150 = 1.5x)
        if (multiplier > 0) {
            payout = (operationalWager * multiplier) / 100;
        }

        // Jackpot Payout (Extraordinary Remuneration)
        // Rust already validates if mode allows Jackpot
        if (isJackpot) {
            uint256 jackpotWin = jackpotBalance;
            payout += jackpotWin;
            jackpotBalance = 0; // Reset
            emit JackpotHit(msg.sender, jackpotWin);
        }

        // 6. Settlement
        if (payout > 0) {
            // Solvency Check: Cap payout to available contract balance
            uint256 balance = bkcToken.balanceOf(address(this));
            if (payout > balance) {
                payout = balance;
            }
            bkcToken.safeTransfer(msg.sender, payout);
        } 
        
        // If loss (or partial win less than wager), process mining
        // We consider the operational amount as "spent" for mining purposes
        if (payout < operationalWager) {
            uint256 burnAmount = operationalWager; 
            // If partial win, we could adjust logic, but standard PoP mines the full spent fee
            if (miningManager != address(0)) {
                bkcToken.safeTransfer(miningManager, burnAmount);
                IMiningManager(miningManager).performPurchaseMining(SERVICE_KEY, burnAmount);
            }
        }

        // 7. Emit Event (Frontend will use 'rolls' vs 'guesses' & 'mode' to show FOMO)
        emit GamePlayed(
            msg.sender, 
            _mode, 
            _wagerTotal, 
            payout, 
            msg.value, 
            rolls, 
            _guesses,
            isJackpot
        );
    }

    // Allow receiving ETH to cover gas if necessary
    receive() external payable {}
}